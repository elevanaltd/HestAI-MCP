# HestAI Review Gate v3.0.0 - Governance Socket
# Source: https://github.com/elevanaltd/HestAI-MCP
# Last updated: 2026-02-10 (Governance Socket: reusable workflow_call support)
#
# This workflow runs review validation for PRs. It supports two modes:
#   1. LOCAL:  Triggered directly by HestAI-MCP's own PRs (pull_request / issue_comment)
#   2. REMOTE: Called by other repos via workflow_call (Governance Socket pattern)
#
# For consuming repos, copy review-gate-caller.yml.template to your
# .github/workflows/review-gate.yml - see that file for details.

name: Review Gate

on:
  pull_request:
    types: [opened, synchronize, reopened, edited]
  issue_comment:
    types: [created, edited]
  workflow_call:

jobs:
  check-review:
    runs-on: ubuntu-latest
    # Only run on PR comments or PR events
    # workflow_call does not set issue_comment context, so we also allow it through
    if: >-
      github.event_name == 'pull_request'
      || github.event_name == 'workflow_call'
      || github.event.issue.pull_request

    # Required for PR commenting
    permissions:
      contents: read
      pull-requests: write
      issues: write

    steps:
      # --- Determine execution context ---
      - name: Detect execution context
        id: context
        run: |
          if [ "${{ github.repository }}" = "elevanaltd/HestAI-MCP" ]; then
            echo "mode=local" >> $GITHUB_OUTPUT
            echo "script_path=scripts/validate_review.py" >> $GITHUB_OUTPUT
          else
            echo "mode=remote" >> $GITHUB_OUTPUT
            echo "script_path=.review-gate-tools/scripts/validate_review.py" >> $GITHUB_OUTPUT
          fi

      # --- Cross-repo: fetch review-gate tooling from HestAI-MCP ---
      - name: Checkout review-gate tooling
        if: steps.context.outputs.mode == 'remote'
        uses: actions/checkout@v4
        with:
          repository: elevanaltd/HestAI-MCP
          path: .review-gate-tools
          sparse-checkout: scripts/validate_review.py
          sparse-checkout-cone-mode: false

      # --- Checkout the target repo (caller or self) ---
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Get PR Number
        id: pr
        run: |
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            echo "number=${{ github.event.pull_request.number }}" >> $GITHUB_OUTPUT
          else
            # For issue_comment events on PRs
            PR_NUMBER=$(echo "${{ github.event.issue.pull_request.url }}" | grep -oE '[0-9]+$')
            echo "number=${PR_NUMBER}" >> $GITHUB_OUTPUT
          fi

      - name: Check Review Requirements
        id: review_check
        env:
          GH_TOKEN: ${{ github.token }}
          CI: true
          PR_NUMBER: ${{ steps.pr.outputs.number }}
        run: |
          # Universal PR checkout - works for both same-repo and fork PRs
          PR_NUMBER="${{ steps.pr.outputs.number }}"

          # Get base ref for comparison
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            BASE_REF="${{ github.event.pull_request.base.ref }}"
          else
            # For issue_comment events, fetch PR details via API
            PR_DATA=$(gh pr view "$PR_NUMBER" --json baseRefName)
            BASE_REF=$(echo "$PR_DATA" | jq -r '.baseRefName')
          fi

          echo "PR Number: $PR_NUMBER"
          echo "Base ref: $BASE_REF"

          # Fetch base branch
          git fetch origin "$BASE_REF"
          export GITHUB_BASE_REF="origin/$BASE_REF"

          # Fetch and checkout PR using GitHub's universal PR ref
          # This works for all PRs (same-repo and forks)
          git fetch origin "refs/pull/$PR_NUMBER/head:pr-$PR_NUMBER"
          git checkout "pr-$PR_NUMBER"

          # Run validation using context-appropriate script path
          SCRIPT_PATH="${{ steps.context.outputs.script_path }}"
          echo "Running: python3 $SCRIPT_PATH"

          set +e  # Don't exit on error
          OUTPUT=$(python3 "$SCRIPT_PATH" 2>&1)
          EXIT_CODE=$?
          set -e

          # Save output for next step
          echo "$OUTPUT"
          echo "$OUTPUT" > /tmp/review_output.txt

          # Set output for next step
          echo "exit_code=$EXIT_CODE" >> $GITHUB_OUTPUT

          exit $EXIT_CODE

      - name: Update PR Status
        if: always()
        uses: actions/github-script@v7
        env:
          REVIEW_EXIT_CODE: ${{ steps.review_check.outputs.exit_code }}
          PR_NUMBER: ${{ steps.pr.outputs.number }}
        with:
          script: |
            const fs = require('fs');
            const prNumber = process.env.PR_NUMBER;
            const exitCode = process.env.REVIEW_EXIT_CODE;
            const success = exitCode === '0';

            // Read validation output if available
            let validationOutput = '';
            try {
              validationOutput = fs.readFileSync('/tmp/review_output.txt', 'utf8');
            } catch (e) {
              validationOutput = 'Unable to read validation output';
            }

            // Parse key information from output
            const tierMatch = validationOutput.match(/üìã Review Tier: (\S+)/);
            const reasonMatch = validationOutput.match(/Reason: (.+)/);
            const tier = tierMatch ? tierMatch[1] : 'UNKNOWN';

            // Build status message
            const status = success ? '‚úÖ' : '‚ùå';
            let message = '';

            if (success) {
              message = '**Review requirements satisfied**\n\n';
              message += `**Tier**: ${tier}\n`;
              message += validationOutput.includes('TIER_0_EXEMPT')
                ? '‚úì Exempt from review (docs/tests only)\n'
                : '‚úì Required approvals found\n';
            } else {
              message = '**Review requirements not met**\n\n';
              message += `**Tier**: ${tier}\n`;

              if (reasonMatch) {
                message += `**Reason**: ${reasonMatch[1]}\n\n`;
              }

              // Extract required reviews from output
              if (tier === 'TIER_1_SELF') {
                message += '**Required**: Add a comment with:\n';
                message += '```\nIL SELF-REVIEWED: [your rationale for this change]\n```\n';
              } else if (tier === 'TIER_2_CRS') {
                message += '**Required**: Code Review Specialist approval with:\n';
                message += '```\nCRS APPROVED: [assessment of change]\n```\n';
              } else if (tier === 'TIER_3_FULL') {
                message += '**Required**: Both approvals with:\n';
                message += '```\nCRS APPROVED: [assessment]\nCE APPROVED: [critical assessment]\n```\n';
              }

              message += '\n<details><summary>üìã Full Validation Output</summary>\n\n';
              message += '```\n' + validationOutput + '\n```\n';
              message += '</details>\n';
            }

            // Add or update status comment
            const marker = '<!-- review-gate-status -->';
            const body = `${marker}\n## Review Gate Status: ${status}\n\n${message}`;

            try {
              const { data: comments } = await github.rest.issues.listComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber
              });

              const botComment = comments.find(c =>
                c.user.type === 'Bot' && c.body.includes(marker)
              );

              if (botComment) {
                await github.rest.issues.updateComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  comment_id: botComment.id,
                  body
                });
                console.log('Updated existing review status comment');
              } else {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: prNumber,
                  body
                });
                console.log('Created new review status comment');
              }
            } catch (error) {
              console.error('Failed to update PR comment:', error);
              core.setFailed(`Failed to update PR status: ${error.message}`);
            }
