===COMPILED_DECISION===

META:
  TYPE::COMPILED_DECISION
  VERSION::"1.0"
  THREAD_ID::"2026-02-14-review-tool-placement"
  TOPIC::"Where should the MCP review submission tool live — hestai-mcp (alongside the review gate CI), debate-hall-mcp (alongside RACI deliberation), or a third-way architecture? The tool lets agents (CRS, CE, IL) submit structured review findings as PR comments that clear the review-gate CI check. Key tension: the review gate CI + validation script + governance rules all live in hestai-mcp, but debate-hall-mcp owns multi-agent structured deliberation and is evolving toward stateful RACI (issue #163). The ecosystem spans multiple MCP servers."
  DECIDED_AT::"2026-02-14T14:11:44.328808+00:00"

OUTCOME:
  SYNTHESIS::"DECISION: submit_review MCP tool lives in hestai-mcp.\n\nREASONING:\n1. The controller/actuator pattern resolves the multi-MCP boundary tension cleanly — hestai-mcp actuates (formats + posts PR comments), debate-hall-mcp controls (orchestrates who reviews, when, how).\n2. Co-locating submit_review with validate_review.py eliminates format drift risk — they share the same regex patterns and format constants, proven fragile by evidence of past format evolution.\n3. hestai-mcp already holds the GitHub API surface (PR write permissions in review-gate.yml) — debate-hall-mcp has none.\n4. The tool works standalone today with zero dependency on debate-hall's unbuilt #163 RACI infrastructure, but integrates naturally when that arrives.\n5. This follows the existing Governance Socket pattern where hestai-mcp is the callable service and other systems (including debate-hall) invoke it."
  DECISION_HASH::"5ca65e9352ac1b4e01116ce8d2a8e98ffa2f9e277755be57ac03181cb8398b98"
  STATUS::synthesis

RATIONALE:
  WIND_PERSPECTIVES::[
    "## Possibility Space\n\nThe framing of \"hestai-mcp vs debate-hall-mcp\" is a false binary. Let me expand the space:\n\n### Option A: hestai-mcp (gate-adjacent)\nThe review tool lives next to validate_review.py. Producer and consumer are co-located. The tool knows the exact format the gate expects because it shares the codebase.\n\n### Option B: debate-hall-mcp (deliberation-adjacent)\nThe tool lives alongside RACI/W-W-D. Agents doing reviews are already in deliberation context. Issue #163's stateful hall would orchestrate reviews naturally.\n\n### Option C: THE EDGE — Split the atom\nWhat if the tool isn't one tool at all? Consider:\n\n1. **`submit_review`** — a thin MCP tool in **hestai-mcp** that does ONE thing: posts a correctly-formatted PR comment (`CRS APPROVED: {assessment}`) and validates it would clear the gate. It's essentially the write-side of validate_review.py. Same codebase, shared format constants, zero format drift risk.\n\n2. **debate-hall-mcp's RACI evolution** (issue #163) orchestrates WHEN and HOW reviews happen — which agents review, in what order, with what context. It calls `submit_review` as an action at the end of a C-phase.\n\nThis is the **controller/actuator** pattern. Debate-hall is the controller (decides). Hestai-mcp is the actuator (executes the PR comment). Neither needs to know the other's internals.\n\n### Option D: The hidden insight — format as protocol\nWhat if `validate_review.py` already defines an implicit protocol? The magic strings (\"CRS APPROVED:\", \"CE APPROVED:\") are a contract. The submission tool is just a client of that contract. Co-locating it with the contract definition prevents version skew.\n\n### Why this matters for the ecosystem\nMulti-MCP ecosystems need clear boundaries. The principle should be: **the tool that writes to a gate should live with the gate that reads it**. The tool that decides what to write can live anywhere. This is how real systems work — the database driver lives with the database, not with the application that queries it.\n\n### Wild possibility\nWhat if `validate_review.py` exports its format constants as a reusable module, and the submission tool imports them directly? Then format changes are mechanically impossible to drift. This is impossible if the tool lives in a different repo.",
  ]
  WALL_CONSTRAINTS::[
    "## Constraint Analysis\n\n### VERDICT: Wind's Option C is structurally sound. Submission tool MUST live in hestai-mcp.\n\n### [EVIDENCE]\n\n**E1: Format coupling is proven fragile.** validate_review.py already evolved from exact string matching to flexible regex patterns accepting variations like \"CRS (Gemini): APPROVED\" and markdown table formats. A tool in a separate repo would have broken during that evolution with no compile-time signal.\n\n**E2: GitHub API surface exists only in hestai-mcp.** review-gate.yml declares `pull-requests: write` and `issues: write` permissions. debate-hall-mcp has zero GitHub API tools today — adding PR comment capability would duplicate infrastructure.\n\n**E3: The reusable workflow pattern proves the model.** review-gate.yml v3.0.0 \"Governance Socket\" already works as a callable from other repos via `workflow_call`. This proves hestai-mcp is designed to be the actuator that other systems call into.\n\n**E4: Issue #163 is aspirational.** The stateful RACI hall is labeled \"v2.0 effort\". Building a review submission tool dependent on unbuilt infrastructure violates I2 (structural integrity over velocity).\n\n**E5: Same-repo import eliminates drift.** A submission tool co-located with validate_review.py can import the same regex patterns, tier logic, and format constants. Cross-repo would require duplicating or publishing these as a shared package — unnecessary complexity.\n\n### Hard Constraints\n\n**C1: Format coupling** — submission and validation MUST share format definitions. Same repo solves this mechanically.\n\n**C2: GitHub API** — posting PR comments requires tokens and permissions already held by hestai-mcp's CI context.\n\n**C3: Existing patterns** — the Governance Socket pattern proves hestai-mcp is designed as a callable service.\n\n### Risk Assessment\n- **Option A (hestai-mcp only)**: Low risk. Works today.\n- **Option B (debate-hall only)**: High risk. Format drift, no GitHub API, depends on #163.\n- **Option C (split actuator/controller)**: Lowest risk. Actuator in hestai-mcp, orchestration wherever.\n- **Option D (shared module)**: Over-engineered. Cross-repo package management for a string format.",
  ]
  DOOR_REFINEMENTS::[
    "## Synthesis: The Actuator Pattern\n\n### Resolution\n\nWind and Wall converge on Option C — the **controller/actuator split** — but let me sharpen it into an actionable architecture:\n\n### The Architecture\n\n```\n┌─────────────────────────────────┐     ┌──────────────────────────────┐\n│  debate-hall-mcp                │     │  hestai-mcp                  │\n│                                 │     │                              │\n│  RACI orchestration (issue #163)│     │  submit_review (MCP tool)    │\n│  W/W/D debates                  │────▶│    ├─ formats PR comment     │\n│  \"who reviews, when, how\"       │     │    ├─ validates against gate │\n│                                 │     │    └─ posts via GitHub API   │\n│  Controller: DECIDES            │     │                              │\n│                                 │     │  validate_review.py (CI)     │\n│                                 │     │    └─ reads PR comments      │\n│                                 │     │                              │\n│                                 │     │  Actuator: EXECUTES          │\n└─────────────────────────────────┘     └──────────────────────────────┘\n```\n\n### Why this is the third way\n\n1. **submit_review lives in hestai-mcp** because it shares format definitions with validate_review.py. Wind identified this as \"the tool that writes to a gate should live with the gate that reads it.\" Wall proved this with evidence of format evolution (E1).\n\n2. **debate-hall-mcp orchestrates reviews** when RACI mode is active. It calls submit_review as the final action of a C-phase. But submit_review works perfectly fine WITHOUT debate-hall — any agent can call it directly.\n\n3. **No cross-repo format coupling.** The submission tool can literally import validation logic from validate_review.py or share constants. Format changes propagate mechanically.\n\n4. **No dependency on #163.** The tool works today, standalone. When stateful RACI arrives, it becomes a natural action endpoint.\n\n### The tool design\n\n`submit_review` MCP tool in hestai-mcp:\n- **Inputs**: repo, pr_number, role (CRS|CE|IL), verdict (APPROVED|BLOCKED|CONDITIONAL), assessment, model_annotation (optional)\n- **Actions**: (1) Format the comment using the same patterns validate_review.py accepts, (2) Optionally dry-run validate before posting, (3) Post via GitHub API\n- **Output**: Comment URL + validation result\n\n### Integration contract with debate-hall\n\ndebate-hall doesn't need to know about submit_review at all. When #163 lands, the RACI C-phase agent (CRS/CE) simply has hestai-mcp tools available (as they already do) and calls submit_review after deliberation. The debate transcript feeds the assessment content. No coupling required.\n\n### Decision\n\n**submit_review → hestai-mcp.** Debate-hall remains the brain. Hestai-mcp remains the hands. Each MCP server owns its domain boundary cleanly.",
  ]

VALIDATION:
  CONSENSUS_REACHED::false
  VOTES::{wind:null,wall:null}
  REFINEMENT_COUNT::0
  TURN_COUNT::3

PROVENANCE:
  EXTRACTED_AT::"2026-02-14T14:12:02.349844+00:00"
  SOURCE_HASH::"c57fa50a4f9ec629a49931d3b17009f2d646cc8f58c9855aca27e8d169b356be"

===END===